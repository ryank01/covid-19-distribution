{"ast":null,"code":"import { Component, createElement } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(\"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n/**\n * Returns the *x* and *y* coordinates of the mouse relative to the svg root container element.\n * The coordinates are returned as an array of two-elements \\[*x*, *y*].\n * Inspired by https://raw.githubusercontent.com/d3/d3-selection/master/src/point.js\n * @param svg the root svg container element\n * @param event the mouse event\n */\n\n\nvar svgPoint = function svgPoint(svg, event) {\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX;\n    point.y = event.clientY;\n    point = point.matrixTransform(svg.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = svg.getBoundingClientRect();\n  return [event.clientX - rect.left - svg.clientLeft, event.clientY - rect.top - svg.clientTop];\n};\n\nvar TooltipComponent = /*#__PURE__*/function (_React$Component) {\n  _inherits(TooltipComponent, _React$Component);\n\n  function TooltipComponent() {\n    var _this;\n\n    _classCallCheck(this, TooltipComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TooltipComponent).apply(this, arguments));\n    _this.state = {\n      type: 'TooltipHidden'\n    };\n\n    _this.updateTooltip = function (evt) {\n      if (_this.props) {\n        var svg = _this.props.containerRef ? _this.props.containerRef.current : _this.safeMouseTrigger ? _this.safeMouseTrigger.ownerSVGElement : undefined;\n\n        if (svg) {\n          var mousePosition = svgPoint(svg, evt);\n\n          _this.setState({\n            type: 'TooltipVisible',\n            svgSvgElement: svg,\n            x: mousePosition[0],\n            y: mousePosition[1]\n          });\n        }\n      }\n    };\n\n    _this.hideTooltip = function () {\n      _this.setState({\n        type: 'TooltipHidden'\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(TooltipComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var mouseTrigger = this.props.triggerRef.current;\n\n      if (mouseTrigger && mouseTrigger.addEventListener) {\n        this.safeMouseTrigger = mouseTrigger;\n        mouseTrigger.addEventListener(\"mouseover\", this.updateTooltip);\n        mouseTrigger.addEventListener(\"mousemove\", this.updateTooltip);\n        mouseTrigger.addEventListener(\"mouseleave\", this.hideTooltip);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.state.type === 'TooltipHidden') {\n        return createElement(\"g\", null);\n      } else {\n        var x = this.state.x;\n        var y = this.state.y;\n        var tooltip = createElement(\"g\", {\n          className: \"Tooltip\",\n          transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n          pointerEvents: \"none\" // tooltip should never grab mouse > prevent flickering\n\n        }, this.props.children instanceof Function ? this.props.children(x, y) : this.props.children);\n        return createPortal(tooltip, this.state.svgSvgElement);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.safeMouseTrigger && this.safeMouseTrigger.removeEventListener) {\n        this.safeMouseTrigger.removeEventListener(\"mouseover\", this.updateTooltip);\n        this.safeMouseTrigger.removeEventListener(\"mousemove\", this.updateTooltip);\n        this.safeMouseTrigger.removeEventListener(\"mouseleave\", this.hideTooltip);\n      }\n    }\n  }]);\n\n  return TooltipComponent;\n}(Component);\n\nexport { TooltipComponent as Tooltip, svgPoint };","map":{"version":3,"sources":["../src/svg-point.ts","../src/Tooltip.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;AAOA,IAAM,QAAQ,GAAG,SAAX,QAAW,CAAA,GAAA,EAAA,KAAA,EAAA;MACT,GAAG,CAAP,c,EAAwB;QAChB,KAAK,GAAG,GAAG,CAAf,cAAY,E;AACZ,IAAA,KAAK,CAAL,CAAA,GAAU,KAAK,CAAf,OAAA;AACA,IAAA,KAAK,CAAL,CAAA,GAAU,KAAK,CAAf,OAAA;AACA,IAAA,KAAK,GAAG,KAAK,CAAL,eAAA,CAAsB,GAAG,CAAH,YAAA,GAA9B,OAA8B,EAAtB,CAAR;WACO,CAAC,KAAK,CAAN,CAAA,EAAU,KAAK,CAAtB,CAAO,C;;;MAEL,IAAI,GAAG,GAAG,CAAhB,qBAAa,E;SACN,CAAC,KAAK,CAAL,OAAA,GAAgB,IAAI,CAApB,IAAA,GAA4B,GAAG,CAAhC,UAAA,EAA6C,KAAK,CAAL,OAAA,GAAgB,IAAI,CAApB,GAAA,GAA2B,GAAG,CAAlF,SAAO,C;AATX,CAAA;;IC8ES,gBAAA,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCArD+B,U,CAAhC,O;;UACI,YAAA,IAAA,YAAA,CAAA,gB,EAAA;aACA,gB,GAAA,Y;AACA,QAAA,YAAY,CAAZ,gBAAA,CAAA,WAAA,EAA2C,KAA3C,aAAA;AACA,QAAA,YAAY,CAAZ,gBAAA,CAAA,WAAA,EAAA,KAAA,aAAA;;;;;;;;;;YASM,CAAC,GAAG,KAAA,KAAA,CAAV,C;YAEM,CAAA,GAAA,KAAA,KAAA,CAAN,C;;;;uBAeqB,EAAA,M,CAAA;;4EAEqD,C,IAAA,KAAA,KAAA,CAP1E,Q","sourcesContent":["/**\n * Returns the *x* and *y* coordinates of the mouse relative to the svg root container element.\n * The coordinates are returned as an array of two-elements \\[*x*, *y*].\n * Inspired by https://raw.githubusercontent.com/d3/d3-selection/master/src/point.js\n * @param svg the root svg container element\n * @param event the mouse event\n */\nconst svgPoint = (svg: SVGSVGElement, event: MouseEvent) => {\n    if (svg.createSVGPoint) {\n        let point = svg.createSVGPoint()\n        point.x = event.clientX\n        point.y = event.clientY\n        point = point.matrixTransform(svg.getScreenCTM().inverse())\n        return [point.x, point.y]\n    }\n    const rect = svg.getBoundingClientRect()\n    return [event.clientX - rect.left - svg.clientLeft, event.clientY - rect.top - svg.clientTop]\n}\n\nexport default svgPoint\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\nimport svgPoint from './svg-point'\n\ntype Props = Readonly<{\n    triggerRef: React.RefObject<SVGElement>\n    containerRef?: React.RefObject<SVGSVGElement>\n    children: React.ReactNode | ((xOffset: number, yOffset: number) => React.ReactNode)\n}>\n\ntype TooltipHidden = Readonly<{\n    type: 'TooltipHidden'\n}>\n\ntype TooltipVisible = Readonly<{\n    type: 'TooltipVisible'\n    svgSvgElement: SVGSVGElement\n    x: number\n    y: number\n}>\n\ntype State = TooltipHidden | TooltipVisible\n\nexport class TooltipComponent extends React.Component<Props, State> {\n    public readonly state: Readonly<State> = { type: 'TooltipHidden' }\n\n    // Keep a reference to the mouse event triggering DOM node\n    // `triggerRef` may be null by the time we want to remove listeners\n    private safeMouseTrigger\n\n    public componentDidMount() {\n        const mouseTrigger = this.props.triggerRef.current\n        if (mouseTrigger && mouseTrigger.addEventListener) {\n            this.safeMouseTrigger = mouseTrigger\n            mouseTrigger.addEventListener(`mouseover`, this.updateTooltip)\n            mouseTrigger.addEventListener(`mousemove`, this.updateTooltip)\n            mouseTrigger.addEventListener(`mouseleave`, this.hideTooltip)\n        }\n    }\n\n    public render() {\n        if (this.state.type === 'TooltipHidden') {\n            return <g />\n        } else {\n            const x = this.state.x\n            const y = this.state.y\n\n            const tooltip = (\n                <g\n                    className=\"Tooltip\"\n                    transform={`translate(${x}, ${y})`}\n                    pointerEvents=\"none\" // tooltip should never grab mouse > prevent flickering\n                >\n                    {this.props.children instanceof Function ? this.props.children(x, y) : this.props.children}\n                </g>\n            )\n\n            return ReactDOM.createPortal(tooltip, this.state.svgSvgElement)\n        }\n    }\n\n    public componentWillUnmount() {\n        if (this.safeMouseTrigger && this.safeMouseTrigger.removeEventListener) {\n            this.safeMouseTrigger.removeEventListener(`mouseover`, this.updateTooltip)\n            this.safeMouseTrigger.removeEventListener(`mousemove`, this.updateTooltip)\n            this.safeMouseTrigger.removeEventListener(`mouseleave`, this.hideTooltip)\n        }\n    }\n\n    private readonly updateTooltip = (evt: MouseEvent) => {\n        if (this.props) {\n            const svg = this.props.containerRef\n                ? this.props.containerRef.current\n                : this.safeMouseTrigger\n                ? this.safeMouseTrigger.ownerSVGElement\n                : undefined\n            if (svg) {\n                const mousePosition = svgPoint(svg, evt)\n                this.setState({\n                    type: 'TooltipVisible',\n                    svgSvgElement: svg,\n                    x: mousePosition[0],\n                    y: mousePosition[1]\n                })\n            }\n        }\n    }\n\n    private readonly hideTooltip = () => {\n        this.setState({ type: 'TooltipHidden' })\n    }\n}\n\nexport default TooltipComponent\n"]},"metadata":{},"sourceType":"module"}