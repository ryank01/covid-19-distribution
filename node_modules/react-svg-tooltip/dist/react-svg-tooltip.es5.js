import { Component, createElement } from 'react';
import { createPortal } from 'react-dom';

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume("next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

/**
 * Returns the *x* and *y* coordinates of the mouse relative to the svg root container element.
 * The coordinates are returned as an array of two-elements \[*x*, *y*].
 * Inspired by https://raw.githubusercontent.com/d3/d3-selection/master/src/point.js
 * @param svg the root svg container element
 * @param event the mouse event
 */
var svgPoint = function svgPoint(svg, event) {
  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX;
    point.y = event.clientY;
    point = point.matrixTransform(svg.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = svg.getBoundingClientRect();
  return [event.clientX - rect.left - svg.clientLeft, event.clientY - rect.top - svg.clientTop];
};

var TooltipComponent =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TooltipComponent, _React$Component);

  function TooltipComponent() {
    var _this;

    _classCallCheck(this, TooltipComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TooltipComponent).apply(this, arguments));
    _this.state = {
      type: 'TooltipHidden'
    };

    _this.updateTooltip = function (evt) {
      if (_this.props) {
        var svg = _this.props.containerRef ? _this.props.containerRef.current : _this.safeMouseTrigger ? _this.safeMouseTrigger.ownerSVGElement : undefined;

        if (svg) {
          var mousePosition = svgPoint(svg, evt);

          _this.setState({
            type: 'TooltipVisible',
            svgSvgElement: svg,
            x: mousePosition[0],
            y: mousePosition[1]
          });
        }
      }
    };

    _this.hideTooltip = function () {
      _this.setState({
        type: 'TooltipHidden'
      });
    };

    return _this;
  }

  _createClass(TooltipComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var mouseTrigger = this.props.triggerRef.current;

      if (mouseTrigger && mouseTrigger.addEventListener) {
        this.safeMouseTrigger = mouseTrigger;
        mouseTrigger.addEventListener("mouseover", this.updateTooltip);
        mouseTrigger.addEventListener("mousemove", this.updateTooltip);
        mouseTrigger.addEventListener("mouseleave", this.hideTooltip);
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this.state.type === 'TooltipHidden') {
        return createElement("g", null);
      } else {
        var x = this.state.x;
        var y = this.state.y;
        var tooltip = createElement("g", {
          className: "Tooltip",
          transform: "translate(".concat(x, ", ").concat(y, ")"),
          pointerEvents: "none" // tooltip should never grab mouse > prevent flickering

        }, this.props.children instanceof Function ? this.props.children(x, y) : this.props.children);
        return createPortal(tooltip, this.state.svgSvgElement);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.safeMouseTrigger && this.safeMouseTrigger.removeEventListener) {
        this.safeMouseTrigger.removeEventListener("mouseover", this.updateTooltip);
        this.safeMouseTrigger.removeEventListener("mousemove", this.updateTooltip);
        this.safeMouseTrigger.removeEventListener("mouseleave", this.hideTooltip);
      }
    }
  }]);

  return TooltipComponent;
}(Component);

export { TooltipComponent as Tooltip, svgPoint };
//# sourceMappingURL=react-svg-tooltip.es5.js.map
